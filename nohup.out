[NbConvertApp] Searching [u'/Users/user148060/Desktop/headlines_limpio', '/Users/user148060/.jupyter', '/Users/user148060/miniconda2/envs/notebook/etc/jupyter', '/usr/local/etc/jupyter', '/etc/jupyter'] for config files
[NbConvertApp] Looking for jupyter_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Looking for jupyter_nbconvert_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Converting notebook train.ipynb to notebook
[NbConvertApp] Notebook name is 'train'
[NbConvertApp] Applying preprocessor: ExecutePreprocessor
[NbConvertApp] Starting kernel: [u'/Users/user148060/miniconda2/envs/notebook/bin/python', u'-m', u'ipykernel_launcher', u'-f', u'/var/folders/3h/sm3_vrhd2_g9nf04jwst60h40000gt/T/tmpwLIcAw.json']
[NbConvertApp] Connecting to: tcp://127.0.0.1:50001
[NbConvertApp] connecting shell channel to tcp://127.0.0.1:49998
[NbConvertApp] Connecting to: tcp://127.0.0.1:49998
[NbConvertApp] connecting iopub channel to tcp://127.0.0.1:49999
[NbConvertApp] Connecting to: tcp://127.0.0.1:49999
[NbConvertApp] connecting stdin channel to tcp://127.0.0.1:50000
[NbConvertApp] Connecting to: tcp://127.0.0.1:50000
[NbConvertApp] connecting heartbeat channel to tcp://127.0.0.1:50002
[NbConvertApp] Executing notebook with kernel: python2
[NbConvertApp] Executing cell:
FN = 'train'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import os
os.environ['THEANO_FLAGS'] = 'device=cpu,floatX=float32'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import keras
keras.__version__
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: error
[NbConvertApp] output: status
[NbConvertApp] ERROR | Error while converting 'train.ipynb'
Traceback (most recent call last):
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/nbconvertapp.py", line 407, in export_single_notebook
    output, resources = self.exporter.from_filename(notebook_filename, resources=resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 178, in from_filename
    return self.from_file(f, resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 196, in from_file
    return self.from_notebook_node(nbformat.read(file_stream, as_version=4), resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/notebook.py", line 32, in from_notebook_node
    nb_copy, resources = super(NotebookExporter, self).from_notebook_node(nb, resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 138, in from_notebook_node
    nb_copy, resources = self._preprocess(nb_copy, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 315, in _preprocess
    nbc, resc = preprocessor(nbc, resc)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 47, in __call__
    return self.preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 354, in preprocess
    nb, resources = super(ExecutePreprocessor, self).preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 69, in preprocess
    nb.cells[index], resources = self.preprocess_cell(cell, resources, index)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 378, in preprocess_cell
    raise CellExecutionError.from_cell_and_msg(cell, out)
CellExecutionError: An error occurred while executing the following cell:
------------------
import keras
keras.__version__
------------------

[0;31m[0m
[0;31mImportError[0mTraceback (most recent call last)
[0;32m<ipython-input-3-98cd3281928c>[0m in [0;36m<module>[0;34m()[0m
[0;32m----> 1[0;31m [0;32mimport[0m [0mkeras[0m[0;34m[0m[0m
[0m[1;32m      2[0m [0mkeras[0m[0;34m.[0m[0m__version__[0m[0;34m[0m[0m

[0;31mImportError[0m: No module named keras
ImportError: No module named keras

[NbConvertApp] Exiting application: jupyter-nbconvert
[NbConvertApp] Searching [u'/Users/user148060/Desktop/headlines_limpio', '/Users/user148060/.jupyter', '/Users/user148060/miniconda2/envs/notebook/etc/jupyter', '/usr/local/etc/jupyter', '/etc/jupyter'] for config files
[NbConvertApp] Looking for jupyter_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Looking for jupyter_nbconvert_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Converting notebook train.ipynb to notebook
[NbConvertApp] Notebook name is 'train'
[NbConvertApp] Applying preprocessor: ExecutePreprocessor
[NbConvertApp] Starting kernel: [u'/Users/user148060/miniconda2/envs/notebook/bin/python', u'-m', u'ipykernel_launcher', u'-f', u'/var/folders/3h/sm3_vrhd2_g9nf04jwst60h40000gt/T/tmpDRC67g.json']
[NbConvertApp] Connecting to: tcp://127.0.0.1:50059
[NbConvertApp] connecting shell channel to tcp://127.0.0.1:50056
[NbConvertApp] Connecting to: tcp://127.0.0.1:50056
[NbConvertApp] connecting iopub channel to tcp://127.0.0.1:50057
[NbConvertApp] Connecting to: tcp://127.0.0.1:50057
[NbConvertApp] connecting stdin channel to tcp://127.0.0.1:50058
[NbConvertApp] Connecting to: tcp://127.0.0.1:50058
[NbConvertApp] connecting heartbeat channel to tcp://127.0.0.1:50060
[NbConvertApp] Executing notebook with kernel: python2
[NbConvertApp] Executing cell:
FN = 'train'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import os
os.environ['THEANO_FLAGS'] = 'device=cpu,floatX=float32'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import keras
keras.__version__
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: error
[NbConvertApp] output: status
[NbConvertApp] ERROR | Error while converting 'train.ipynb'
Traceback (most recent call last):
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/nbconvertapp.py", line 407, in export_single_notebook
    output, resources = self.exporter.from_filename(notebook_filename, resources=resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 178, in from_filename
    return self.from_file(f, resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 196, in from_file
    return self.from_notebook_node(nbformat.read(file_stream, as_version=4), resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/notebook.py", line 32, in from_notebook_node
    nb_copy, resources = super(NotebookExporter, self).from_notebook_node(nb, resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 138, in from_notebook_node
    nb_copy, resources = self._preprocess(nb_copy, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 315, in _preprocess
    nbc, resc = preprocessor(nbc, resc)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 47, in __call__
    return self.preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 354, in preprocess
    nb, resources = super(ExecutePreprocessor, self).preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 69, in preprocess
    nb.cells[index], resources = self.preprocess_cell(cell, resources, index)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 378, in preprocess_cell
    raise CellExecutionError.from_cell_and_msg(cell, out)
CellExecutionError: An error occurred while executing the following cell:
------------------
import keras
keras.__version__
------------------

[0;31m[0m
[0;31mImportError[0mTraceback (most recent call last)
[0;32m<ipython-input-3-98cd3281928c>[0m in [0;36m<module>[0;34m()[0m
[0;32m----> 1[0;31m [0;32mimport[0m [0mkeras[0m[0;34m[0m[0m
[0m[1;32m      2[0m [0mkeras[0m[0;34m.[0m[0m__version__[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      1[0m [0;32mfrom[0m [0m__future__[0m [0;32mimport[0m [0mabsolute_import[0m[0;34m[0m[0m
[1;32m      2[0m [0;34m[0m[0m
[0;32m----> 3[0;31m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mutils[0m[0;34m[0m[0m
[0m[1;32m      4[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mactivations[0m[0;34m[0m[0m
[1;32m      5[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mapplications[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/utils/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      4[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mdata_utils[0m[0;34m[0m[0m
[1;32m      5[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mio_utils[0m[0;34m[0m[0m
[0;32m----> 6[0;31m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mconv_utils[0m[0;34m[0m[0m
[0m[1;32m      7[0m [0;34m[0m[0m
[1;32m      8[0m [0;31m# Globally-importable utils.[0m[0;34m[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/utils/conv_utils.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      7[0m [0;32mfrom[0m [0msix[0m[0;34m.[0m[0mmoves[0m [0;32mimport[0m [0mrange[0m[0;34m[0m[0m
[1;32m      8[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0m
[0;32m----> 9[0;31m [0;32mfrom[0m [0;34m.[0m[0;34m.[0m [0;32mimport[0m [0mbackend[0m [0;32mas[0m [0mK[0m[0;34m[0m[0m
[0m[1;32m     10[0m [0;34m[0m[0m
[1;32m     11[0m [0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/backend/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m     87[0m [0;32melif[0m [0m_BACKEND[0m [0;34m==[0m [0;34m'tensorflow'[0m[0;34m:[0m[0;34m[0m[0m
[1;32m     88[0m     [0msys[0m[0;34m.[0m[0mstderr[0m[0;34m.[0m[0mwrite[0m[0;34m([0m[0;34m'Using TensorFlow backend.\n'[0m[0;34m)[0m[0;34m[0m[0m
[0;32m---> 89[0;31m     [0;32mfrom[0m [0;34m.[0m[0mtensorflow_backend[0m [0;32mimport[0m [0;34m*[0m[0;34m[0m[0m
[0m[1;32m     90[0m [0;32melse[0m[0;34m:[0m[0;34m[0m[0m
[1;32m     91[0m     [0;31m# Try and load external backend.[0m[0;34m[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/backend/tensorflow_backend.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      3[0m [0;32mfrom[0m [0m__future__[0m [0;32mimport[0m [0mprint_function[0m[0;34m[0m[0m
[1;32m      4[0m [0;34m[0m[0m
[0;32m----> 5[0;31m [0;32mimport[0m [0mtensorflow[0m [0;32mas[0m [0mtf[0m[0;34m[0m[0m
[0m[1;32m      6[0m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m[0;34m.[0m[0mframework[0m [0;32mimport[0m [0mops[0m [0;32mas[0m [0mtf_ops[0m[0;34m[0m[0m
[1;32m      7[0m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m[0;34m.[0m[0mtraining[0m [0;32mimport[0m [0mmoving_averages[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m     22[0m [0;34m[0m[0m
[1;32m     23[0m [0;31m# pylint: disable=wildcard-import[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 24[0;31m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m [0;32mimport[0m [0;34m*[0m[0;34m[0m[0m
[0m[1;32m     25[0m [0;31m# pylint: enable=wildcard-import[0m[0;34m[0m[0;34m[0m[0m
[1;32m     26[0m [0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m     49[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0m
[1;32m     50[0m [0;34m[0m[0m
[0;32m---> 51[0;31m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m [0;32mimport[0m [0mpywrap_tensorflow[0m[0;34m[0m[0m
[0m[1;32m     52[0m [0;34m[0m[0m
[1;32m     53[0m [0;31m# Protocol buffers[0m[0;34m[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow.py[0m in [0;36m<module>[0;34m()[0m
[1;32m     50[0m [0;32mfor[0m [0msome[0m [0mcommon[0m [0mreasons[0m [0;32mand[0m [0msolutions[0m[0;34m.[0m  [0mInclude[0m [0mthe[0m [0mentire[0m [0mstack[0m [0mtrace[0m[0;34m[0m[0m
[1;32m     51[0m above this error message when asking for help.""" % traceback.format_exc()
[0;32m---> 52[0;31m   [0;32mraise[0m [0mImportError[0m[0;34m([0m[0mmsg[0m[0;34m)[0m[0;34m[0m[0m
[0m[1;32m     53[0m [0;34m[0m[0m
[1;32m     54[0m [0;31m# pylint: enable=wildcard-import,g-import-not-at-top,unused-import,line-too-long[0m[0;34m[0m[0;34m[0m[0m

[0;31mImportError[0m: Traceback (most recent call last):
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow.py", line 41, in <module>
    from tensorflow.python.pywrap_tensorflow_internal import *
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py", line 28, in <module>
    _pywrap_tensorflow_internal = swig_import_helper()
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py", line 24, in swig_import_helper
    _mod = imp.load_module('_pywrap_tensorflow_internal', fp, pathname, description)
ImportError: dlopen(/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so, 10): Library not loaded: @rpath/libcublas.8.0.dylib
  Referenced from: /Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so
  Reason: image not found


Failed to load the native TensorFlow runtime.

See https://www.tensorflow.org/install/install_sources#common_installation_problems

for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.
ImportError: Traceback (most recent call last):
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow.py", line 41, in <module>
    from tensorflow.python.pywrap_tensorflow_internal import *
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py", line 28, in <module>
    _pywrap_tensorflow_internal = swig_import_helper()
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/pywrap_tensorflow_internal.py", line 24, in swig_import_helper
    _mod = imp.load_module('_pywrap_tensorflow_internal', fp, pathname, description)
ImportError: dlopen(/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so, 10): Library not loaded: @rpath/libcublas.8.0.dylib
  Referenced from: /Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so
  Reason: image not found


Failed to load the native TensorFlow runtime.

See https://www.tensorflow.org/install/install_sources#common_installation_problems

for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.

[NbConvertApp] Exiting application: jupyter-nbconvert
[NbConvertApp] Searching [u'/Users/user148060/Desktop/headlines_limpio', '/Users/user148060/.jupyter', '/Users/user148060/miniconda2/envs/notebook/etc/jupyter', '/usr/local/etc/jupyter', '/etc/jupyter'] for config files
[NbConvertApp] Looking for jupyter_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Looking for jupyter_nbconvert_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Converting notebook train.ipynb to notebook
[NbConvertApp] Notebook name is 'train'
[NbConvertApp] Applying preprocessor: ExecutePreprocessor
[NbConvertApp] Starting kernel: [u'/Users/user148060/miniconda2/envs/notebook/bin/python', u'-m', u'ipykernel_launcher', u'-f', u'/var/folders/3h/sm3_vrhd2_g9nf04jwst60h40000gt/T/tmpBPJ2MN.json']
[NbConvertApp] Connecting to: tcp://127.0.0.1:50091
[NbConvertApp] connecting shell channel to tcp://127.0.0.1:50088
[NbConvertApp] Connecting to: tcp://127.0.0.1:50088
[NbConvertApp] connecting iopub channel to tcp://127.0.0.1:50089
[NbConvertApp] Connecting to: tcp://127.0.0.1:50089
[NbConvertApp] connecting stdin channel to tcp://127.0.0.1:50090
[NbConvertApp] Connecting to: tcp://127.0.0.1:50090
[NbConvertApp] connecting heartbeat channel to tcp://127.0.0.1:50092
[NbConvertApp] Executing notebook with kernel: python2
[NbConvertApp] Executing cell:
FN = 'train'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import os
os.environ['THEANO_FLAGS'] = 'device=cpu,floatX=float32'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import keras
keras.__version__
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: error
[NbConvertApp] output: status
[NbConvertApp] ERROR | Error while converting 'train.ipynb'
Traceback (most recent call last):
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/nbconvertapp.py", line 407, in export_single_notebook
    output, resources = self.exporter.from_filename(notebook_filename, resources=resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 178, in from_filename
    return self.from_file(f, resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 196, in from_file
    return self.from_notebook_node(nbformat.read(file_stream, as_version=4), resources=resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/notebook.py", line 32, in from_notebook_node
    nb_copy, resources = super(NotebookExporter, self).from_notebook_node(nb, resources, **kw)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 138, in from_notebook_node
    nb_copy, resources = self._preprocess(nb_copy, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/exporters/exporter.py", line 315, in _preprocess
    nbc, resc = preprocessor(nbc, resc)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 47, in __call__
    return self.preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 354, in preprocess
    nb, resources = super(ExecutePreprocessor, self).preprocess(nb, resources)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/base.py", line 69, in preprocess
    nb.cells[index], resources = self.preprocess_cell(cell, resources, index)
  File "/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/nbconvert/preprocessors/execute.py", line 378, in preprocess_cell
    raise CellExecutionError.from_cell_and_msg(cell, out)
CellExecutionError: An error occurred while executing the following cell:
------------------
import keras
keras.__version__
------------------

[0;31m[0m
[0;31mImportError[0mTraceback (most recent call last)
[0;32m<ipython-input-3-98cd3281928c>[0m in [0;36m<module>[0;34m()[0m
[0;32m----> 1[0;31m [0;32mimport[0m [0mkeras[0m[0;34m[0m[0m
[0m[1;32m      2[0m [0mkeras[0m[0;34m.[0m[0m__version__[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      1[0m [0;32mfrom[0m [0m__future__[0m [0;32mimport[0m [0mabsolute_import[0m[0;34m[0m[0m
[1;32m      2[0m [0;34m[0m[0m
[0;32m----> 3[0;31m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mutils[0m[0;34m[0m[0m
[0m[1;32m      4[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mactivations[0m[0;34m[0m[0m
[1;32m      5[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mapplications[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/utils/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      4[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mdata_utils[0m[0;34m[0m[0m
[1;32m      5[0m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mio_utils[0m[0;34m[0m[0m
[0;32m----> 6[0;31m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0mconv_utils[0m[0;34m[0m[0m
[0m[1;32m      7[0m [0;34m[0m[0m
[1;32m      8[0m [0;31m# Globally-importable utils.[0m[0;34m[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/utils/conv_utils.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      7[0m [0;32mfrom[0m [0msix[0m[0;34m.[0m[0mmoves[0m [0;32mimport[0m [0mrange[0m[0;34m[0m[0m
[1;32m      8[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0m
[0;32m----> 9[0;31m [0;32mfrom[0m [0;34m.[0m[0;34m.[0m [0;32mimport[0m [0mbackend[0m [0;32mas[0m [0mK[0m[0;34m[0m[0m
[0m[1;32m     10[0m [0;34m[0m[0m
[1;32m     11[0m [0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/backend/__init__.py[0m in [0;36m<module>[0;34m()[0m
[1;32m     87[0m [0;32melif[0m [0m_BACKEND[0m [0;34m==[0m [0;34m'tensorflow'[0m[0;34m:[0m[0;34m[0m[0m
[1;32m     88[0m     [0msys[0m[0;34m.[0m[0mstderr[0m[0;34m.[0m[0mwrite[0m[0;34m([0m[0;34m'Using TensorFlow backend.\n'[0m[0;34m)[0m[0;34m[0m[0m
[0;32m---> 89[0;31m     [0;32mfrom[0m [0;34m.[0m[0mtensorflow_backend[0m [0;32mimport[0m [0;34m*[0m[0;34m[0m[0m
[0m[1;32m     90[0m [0;32melse[0m[0;34m:[0m[0;34m[0m[0m
[1;32m     91[0m     [0;31m# Try and load external backend.[0m[0;34m[0m[0;34m[0m[0m

[0;32m/Users/user148060/miniconda2/envs/notebook/lib/python2.7/site-packages/keras/backend/tensorflow_backend.py[0m in [0;36m<module>[0;34m()[0m
[1;32m      3[0m [0;32mfrom[0m [0m__future__[0m [0;32mimport[0m [0mprint_function[0m[0;34m[0m[0m
[1;32m      4[0m [0;34m[0m[0m
[0;32m----> 5[0;31m [0;32mimport[0m [0mtensorflow[0m [0;32mas[0m [0mtf[0m[0;34m[0m[0m
[0m[1;32m      6[0m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m[0;34m.[0m[0mframework[0m [0;32mimport[0m [0mops[0m [0;32mas[0m [0mtf_ops[0m[0;34m[0m[0m
[1;32m      7[0m [0;32mfrom[0m [0mtensorflow[0m[0;34m.[0m[0mpython[0m[0;34m.[0m[0mtraining[0m [0;32mimport[0m [0mmoving_averages[0m[0;34m[0m[0m

[0;31mImportError[0m: No module named tensorflow
ImportError: No module named tensorflow

[NbConvertApp] Exiting application: jupyter-nbconvert
[NbConvertApp] Searching [u'/Users/user148060/Desktop/headlines_limpio', '/Users/user148060/.jupyter', '/Users/user148060/miniconda2/envs/notebook/etc/jupyter', '/usr/local/etc/jupyter', '/etc/jupyter'] for config files
[NbConvertApp] Looking for jupyter_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Looking for jupyter_nbconvert_config in /etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /usr/local/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/miniconda2/envs/notebook/etc/jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/.jupyter
[NbConvertApp] Looking for jupyter_nbconvert_config in /Users/user148060/Desktop/headlines_limpio
[NbConvertApp] Converting notebook train.ipynb to notebook
[NbConvertApp] Notebook name is 'train'
[NbConvertApp] Applying preprocessor: ExecutePreprocessor
[NbConvertApp] Starting kernel: [u'/Users/user148060/miniconda2/envs/notebook/bin/python', u'-m', u'ipykernel_launcher', u'-f', u'/var/folders/3h/sm3_vrhd2_g9nf04jwst60h40000gt/T/tmpfCZGuC.json']
[NbConvertApp] Connecting to: tcp://127.0.0.1:50470
[NbConvertApp] connecting shell channel to tcp://127.0.0.1:50467
[NbConvertApp] Connecting to: tcp://127.0.0.1:50467
[NbConvertApp] connecting iopub channel to tcp://127.0.0.1:50468
[NbConvertApp] Connecting to: tcp://127.0.0.1:50468
[NbConvertApp] connecting stdin channel to tcp://127.0.0.1:50469
[NbConvertApp] Connecting to: tcp://127.0.0.1:50469
[NbConvertApp] connecting heartbeat channel to tcp://127.0.0.1:50471
[NbConvertApp] Executing notebook with kernel: python2
[NbConvertApp] Executing cell:
FN = 'train'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import os
os.environ['THEANO_FLAGS'] = 'device=cpu,floatX=float32'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import keras
keras.__version__
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
FN0 = 'vocabulary-embedding'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
FN1 = 'train'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
maxlend=25 # 0 - if we dont want to use description at all
maxlenh=25
maxlen = maxlend + maxlenh
rnn_size = 512 # must be same as 160330-word-gen
rnn_layers = 3  # match FN1
batch_norm=False
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
activation_rnn_size = 40 if maxlend else 0
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
# training parameters
seed=42
p_W, p_U, p_dense, weight_decay = 0, 0, 0, 0
optimizer = 'adam'
LR = 1e-4
batch_size=64
nflips=10
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
nb_train_samples = 30000
nb_val_samples = 3000
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import cPickle as pickle

with open('data/%s.pkl'%FN0, 'rb') as fp:
    embedding, idx2word, word2idx, glove_idx2idx = pickle.load(fp)
vocab_size, embedding_size = embedding.shape
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
with open('data/%s.data.pkl'%FN0, 'rb') as fp:
    X, Y = pickle.load(fp)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
nb_unknown_words = 10
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
print 'number of examples',len(X),len(Y)
print 'dimension of embedding space for words',embedding_size
print 'vocabulary size', vocab_size, 'the last %d words can be used as place holders for unknown/oov words'%nb_unknown_words
print 'total number of different words',len(idx2word), len(word2idx)
print 'number of words outside vocabulary which we can substitue using glove similarity', len(glove_idx2idx)
print 'number of words that will be regarded as unknonw(unk)/out-of-vocabulary(oov)',len(idx2word)-vocab_size-len(glove_idx2idx)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
for i in range(nb_unknown_words):
    idx2word[vocab_size-1-i] = '<%d>'%i
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
oov0 = vocab_size-nb_unknown_words
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
for i in range(oov0, len(idx2word)):
    idx2word[i] = idx2word[i]+'^'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=nb_val_samples, random_state=seed)
len(X_train), len(Y_train), len(X_test), len(Y_test)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
del X
del Y
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
empty = 0
eos = 1
idx2word[empty] = '_'
idx2word[eos] = '~'
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import numpy as np
from keras.preprocessing import sequence
from keras.utils import np_utils
import random, sys
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def prt(label, x):
    print label+':',
    for w in x:
        print idx2word[w],
    print
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
i = 334
prt('H',Y_train[i])
prt('D',X_train[i])
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
i = 334
prt('H',Y_test[i])
prt('D',X_test[i])
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
from keras.models import Sequential
from keras.layers.core import Dense, Activation, Dropout, RepeatVector
from keras.layers.wrappers import TimeDistributed
from keras.layers.recurrent import LSTM
from keras.layers.embeddings import Embedding
from keras.regularizers import l2
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
# seed weight initialization
random.seed(seed)
np.random.seed(seed)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
regularizer = l2(weight_decay) if weight_decay else None
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
model = Sequential()
model.add(Embedding(vocab_size, embedding_size,
                    input_length=maxlen,
                    embeddings_regularizer=regularizer, weights=[embedding], mask_zero=True,
                    name='embedding_1'))

for i in range(rnn_layers):
    lstm = LSTM(rnn_size, return_sequences=True, # batch_norm=batch_norm,
                kernel_regularizer=regularizer, recurrent_regularizer=regularizer,
                bias_regularizer=regularizer, dropout=p_W, recurrent_dropout=p_U,
                name='lstm_%d'%(i+1)
                  )
    model.add(lstm)
    model.add(Dropout(p_dense,name='dropout_%d'%(i+1)))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
from keras.layers.core import Lambda
import keras.backend as K

def simple_context(X, mask, n=activation_rnn_size, maxlend=maxlend, maxlenh=maxlenh):
    desc, head = X[:,:maxlend,:], X[:,maxlend:,:]
    head_activations, head_words = head[:,:,:n], head[:,:,n:]
    desc_activations, desc_words = desc[:,:,:n], desc[:,:,n:]
    
    # RTFM http://deeplearning.net/software/theano/library/tensor/basic.html#theano.tensor.batched_tensordot
    # activation for every head word and every desc word
    activation_energies = K.batch_dot(head_activations, desc_activations, axes=(2,2))
    # make sure we dont use description words that are masked out
    activation_energies = activation_energies + -1e20*K.expand_dims(1.-K.cast(mask[:, :maxlend],'float32'),1)
    
    # for every head word compute weights for every desc word
    activation_energies = K.reshape(activation_energies,(-1,maxlend))
    activation_weights = K.softmax(activation_energies)
    activation_weights = K.reshape(activation_weights,(-1,maxlenh,maxlend))

    # for every head word compute weighted average of desc words
    desc_avg_word = K.batch_dot(activation_weights, desc_words, axes=(2,1))
    return K.concatenate((desc_avg_word, head_words))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
if activation_rnn_size:
    model.add(Lambda(simple_context,
                     mask = lambda inputs, mask: mask[:,maxlend:],
                     output_shape = lambda input_shape: (input_shape[0], maxlenh, 2*(rnn_size - activation_rnn_size)),
                     name='simplecontext_1'))
model.add(TimeDistributed(Dense(vocab_size,
                                kernel_regularizer=regularizer, bias_regularizer=regularizer,
                                name = 'timedistributed_1')))
model.add(Activation('softmax', name='activation_1'))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
from keras.optimizers import Adam, RMSprop # usually I prefer Adam but article used rmsprop
# opt = Adam(lr=LR)  # keep calm and reduce learning rate
model.compile(loss='categorical_crossentropy', optimizer=optimizer)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
K.set_value(model.optimizer.lr,np.float32(LR))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
model.summary()
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
#if FN1:
#    model.load_weights('data/%s.hdf5'%FN1)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def lpadd(x, maxlend=maxlend, eos=eos):
    """left (pre) pad a description to maxlend and then add eos.
    The eos is the input to predicting the first word in the headline
    """
    assert maxlend >= 0
    if maxlend == 0:
        return [eos]
    n = len(x)
    if n > maxlend:
        x = x[-maxlend:]
        n = maxlend
    return [empty]*(maxlend-n) + x + [eos]
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
samples = [lpadd([3]*26)]
# pad from right (post) so the first maxlend will be description followed by headline
data = sequence.pad_sequences(samples, maxlen=maxlen, value=empty, padding='post', truncating='post')
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
np.all(data[:,maxlend] == eos)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
data.shape,map(len, samples)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
probs = model.predict(data, verbose=0, batch_size=1)
probs.shape
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
# variation to https://github.com/ryankiros/skip-thoughts/blob/master/decoding/search.py
def beamsearch(predict, start=[empty]*maxlend + [eos],
               k=1, maxsample=maxlen, use_unk=True, empty=empty, eos=eos, temperature=1.0):
    """return k samples (beams) and their NLL scores, each sample is a sequence of labels,
    all samples starts with an `empty` label and end with `eos` or truncated to length of `maxsample`.
    You need to supply `predict` which returns the label probability of each sample.
    `use_unk` allow usage of `oov` (out-of-vocabulary) label in samples
    """
    def sample(energy, n, temperature=temperature):
        """sample at most n elements according to their energy"""
        n = min(n,len(energy))
        prb = np.exp(-np.array(energy) / temperature )
        res = []
        for i in xrange(n):
            z = np.sum(prb)
            r = np.argmax(np.random.multinomial(1, prb/z, 1))
            res.append(r)
            prb[r] = 0. # make sure we select each element only once
        return res

    dead_k = 0 # samples that reached eos
    dead_samples = []
    dead_scores = []
    live_k = 1 # samples that did not yet reached eos
    live_samples = [list(start)]
    live_scores = [0]

    while live_k:
        # for every possible live sample calc prob for every possible label 
        probs = predict(live_samples, empty=empty)

        # total score for every sample is sum of -log of word prb
        cand_scores = np.array(live_scores)[:,None] - np.log(probs)
        cand_scores[:,empty] = 1e20
        if not use_unk:
            for i in range(nb_unknown_words):
                cand_scores[:,vocab_size - 1 - i] = 1e20
        live_scores = list(cand_scores.flatten())
        

        # find the best (lowest) scores we have from all possible dead samples and
        # all live samples and all possible new words added
        scores = dead_scores + live_scores
        ranks = sample(scores, k)
        n = len(dead_scores)
        ranks_dead = [r for r in ranks if r < n]
        ranks_live = [r - n for r in ranks if r >= n]
        
        dead_scores = [dead_scores[r] for r in ranks_dead]
        dead_samples = [dead_samples[r] for r in ranks_dead]
        
        live_scores = [live_scores[r] for r in ranks_live]

        # append the new words to their appropriate live sample
        voc_size = probs.shape[1]
        live_samples = [live_samples[r//voc_size]+[r%voc_size] for r in ranks_live]

        # live samples that should be dead are...
        # even if len(live_samples) == maxsample we dont want it dead because we want one
        # last prediction out of it to reach a headline of maxlenh
        zombie = [s[-1] == eos or len(s) > maxsample for s in live_samples]
        
        # add zombies to the dead
        dead_samples += [s for s,z in zip(live_samples,zombie) if z]
        dead_scores += [s for s,z in zip(live_scores,zombie) if z]
        dead_k = len(dead_samples)
        # remove zombies from the living 
        live_samples = [s for s,z in zip(live_samples,zombie) if not z]
        live_scores = [s for s,z in zip(live_scores,zombie) if not z]
        live_k = len(live_samples)

    return dead_samples + live_samples, dead_scores + live_scores
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
# !pip install python-Levenshtein
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def keras_rnn_predict(samples, empty=empty, model=model, maxlen=maxlen):
    """for every sample, calculate probability for every possible label
    you need to supply your RNN model and maxlen - the length of sequences it can handle
    """
    sample_lengths = map(len, samples)
    assert all(l > maxlend for l in sample_lengths)
    assert all(l[maxlend] == eos for l in samples)
    # pad from right (post) so the first maxlend will be description followed by headline
    data = sequence.pad_sequences(samples, maxlen=maxlen, value=empty, padding='post', truncating='post')
    probs = model.predict(data, verbose=0, batch_size=batch_size)
    return np.array([prob[sample_length-maxlend-1] for prob, sample_length in zip(probs, sample_lengths)])
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def vocab_fold(xs):
    """convert list of word indexes that may contain words outside vocab_size to words inside.
    If a word is outside, try first to use glove_idx2idx to find a similar word inside.
    If none exist then replace all accurancies of the same unknown word with <0>, <1>, ...
    """
    xs = [x if x < oov0 else glove_idx2idx.get(x,x) for x in xs]
    # the more popular word is <0> and so on
    outside = sorted([x for x in xs if x >= oov0])
    # if there are more than nb_unknown_words oov words then put them all in nb_unknown_words-1
    outside = dict((x,vocab_size-1-min(i, nb_unknown_words-1)) for i, x in enumerate(outside))
    xs = [outside.get(x,x) for x in xs]
    return xs
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def vocab_unfold(desc,xs):
    # assume desc is the unfolded version of the start of xs
    unfold = {}
    for i, unfold_idx in enumerate(desc):
        fold_idx = xs[i]
        if fold_idx >= oov0:
            unfold[fold_idx] = unfold_idx
    return [unfold.get(x,x) for x in xs]
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
import sys
import Levenshtein

def gensamples(skips=2, k=10, batch_size=batch_size, short=True, temperature=1., use_unk=True):
    i = random.randint(0,len(X_test)-1)
    print 'HEAD:',' '.join(idx2word[w] for w in Y_test[i][:maxlenh])
    print 'DESC:',' '.join(idx2word[w] for w in X_test[i][:maxlend])
    sys.stdout.flush()

    print 'HEADS:'
    x = X_test[i]
    samples = []
    if maxlend == 0:
        skips = [0]
    else:
        skips = range(min(maxlend,len(x)), max(maxlend,len(x)), abs(maxlend - len(x)) // skips + 1)
    for s in skips:
        start = lpadd(x[:s])
        fold_start = vocab_fold(start)
        sample, score = beamsearch(predict=keras_rnn_predict, start=fold_start, k=k, temperature=temperature, use_unk=use_unk)
        assert all(s[maxlend] == eos for s in sample)
        samples += [(s,start,scr) for s,scr in zip(sample,score)]

    samples.sort(key=lambda x: x[-1])
    codes = []
    for sample, start, score in samples:
        code = ''
        words = []
        sample = vocab_unfold(start, sample)[len(start):]
        for w in sample:
            if w == eos:
                break
            words.append(idx2word[w])
            code += chr(w//(256*256)) + chr((w//256)%256) + chr(w%256)
        if short:
            distance = min([100] + [-Levenshtein.jaro(code,c) for c in codes])
            if distance > -0.6:
                print score, ' '.join(words)
        #         print '%s (%.2f) %f'%(' '.join(words), score, distance)
        else:
                print score, ' '.join(words)
        codes.append(code)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
gensamples(skips=2, batch_size=batch_size, k=10, temperature=1.)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: stream
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def flip_headline(x, nflips=None, model=None, debug=False):
    """given a vectorized input (after `pad_sequences`) flip some of the words in the second half (headline)
    with words predicted by the model
    """
    if nflips is None or model is None or nflips <= 0:
        return x
    
    batch_size = len(x)
    assert np.all(x[:,maxlend] == eos)
    probs = model.predict(x, verbose=0, batch_size=batch_size)
    x_out = x.copy()
    for b in range(batch_size):
        # pick locations we want to flip
        # 0...maxlend-1 are descriptions and should be fixed
        # maxlend is eos and should be fixed
        flips = sorted(random.sample(xrange(maxlend+1,maxlen), nflips))
        if debug and b < debug:
            print b,
        for input_idx in flips:
            if x[b,input_idx] == empty or x[b,input_idx] == eos:
                continue
            # convert from input location to label location
            # the output at maxlend (when input is eos) is feed as input at maxlend+1
            label_idx = input_idx - (maxlend+1)
            prob = probs[b, label_idx]
            w = prob.argmax()
            if w == empty:  # replace accidental empty with oov
                w = oov0
            if debug and b < debug:
                print '%s => %s'%(idx2word[x_out[b,input_idx]],idx2word[w]),
            x_out[b,input_idx] = w
        if debug and b < debug:
            print
    return x_out
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def conv_seq_labels(xds, xhs, nflips=None, model=None, debug=False):
    """description and hedlines are converted to padded input vectors. headlines are one-hot to label"""
    batch_size = len(xhs)
    assert len(xds) == batch_size
    x = [vocab_fold(lpadd(xd)+xh) for xd,xh in zip(xds,xhs)]  # the input does not have 2nd eos
    x = sequence.pad_sequences(x, maxlen=maxlen, value=empty, padding='post', truncating='post')
    x = flip_headline(x, nflips=nflips, model=model, debug=debug)
    
    y = np.zeros((batch_size, maxlenh, vocab_size))
    for i, xh in enumerate(xhs):
        xh = vocab_fold(xh) + [eos] + [empty]*maxlenh  # output does have a eos at end
        xh = xh[:maxlenh]
        y[i,:,:] = np_utils.to_categorical(xh, vocab_size)
        
    return x, y
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def gen(Xd, Xh, batch_size=batch_size, nb_batches=None, nflips=None, model=None, debug=False, seed=seed):
    """yield batches. for training use nb_batches=None
    for validation generate deterministic results repeating every nb_batches
    
    while training it is good idea to flip once in a while the values of the headlines from the
    value taken from Xh to value generated by the model.
    """
    c = nb_batches if nb_batches else 0
    while True:
        xds = []
        xhs = []
        if nb_batches and c >= nb_batches:
            c = 0
        new_seed = random.randint(0, sys.maxint)
        random.seed(c+123456789+seed)
        for b in range(batch_size):
            t = random.randint(0,len(Xd)-1)

            xd = Xd[t]
            s = random.randint(min(maxlend,len(xd)), max(maxlend,len(xd)))
            xds.append(xd[:s])
            
            xh = Xh[t]
            s = random.randint(min(maxlenh,len(xh)), max(maxlenh,len(xh)))
            xhs.append(xh[:s])

        # undo the seeding before we yield inorder not to affect the caller
        c+= 1
        random.seed(new_seed)

        yield conv_seq_labels(xds, xhs, nflips=nflips, model=model, debug=debug)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
r = next(gen(X_train, Y_train, batch_size=batch_size))
r[0].shape, r[1].shape, len(r)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
def test_gen(gen, n=5):
    Xtr,Ytr = next(gen)
    for i in range(n):
        assert Xtr[i,maxlend] == eos
        x = Xtr[i,:maxlend]
        y = Xtr[i,maxlend:]
        yy = Ytr[i,:]
        yy = np.where(yy)[1]
        prt('L',yy)
        prt('H',y)
        if maxlend:
            prt('D',x)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
test_gen(gen(X_train, Y_train, batch_size=batch_size))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
test_gen(gen(X_train, Y_train, nflips=6, model=model, debug=False, batch_size=batch_size))
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
valgen = gen(X_test, Y_test,nb_batches=3, batch_size=batch_size)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
for i in range(4):
    test_gen(valgen, n=1)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: stream
[NbConvertApp] output: stream
[NbConvertApp] output: stream
[NbConvertApp] output: stream
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
history = {}
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
traingen = gen(X_train, Y_train, batch_size=batch_size, nflips=nflips, model=model)
valgen = gen(X_test, Y_test, nb_batches=nb_val_samples//batch_size, batch_size=batch_size)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
r = next(traingen)
r[0].shape, r[1].shape, len(r)
[NbConvertApp] output: status
[NbConvertApp] output: execute_input
[NbConvertApp] output: execute_result
[NbConvertApp] output: status
[NbConvertApp] Executing cell:
for iteration in range(500):
    print 'Iteration', iteration
    h = model.fit_generator(traingen, steps_per_epoch=nb_train_samples//batch_size,
                        epochs=1, validation_data=valgen, validation_steps=nb_val_samples
                           )
    for k,v in h.history.iteritems():
        history[k] = history.get(k,[]) + v
    with open('data/%s.history.pkl'%FN,'wb') as fp:
        pickle.dump(history,fp,-1)
    model.save_weights('data/%s.hdf5'%FN, overwrite=True)
    gensamples(batch_size=batch_size)
Error: Missing .floydexpt file, run floyd init first
Code size too large to sync, please keep it under 100.0MiB.
If you have data files in the current directory, please upload them separately using "floyd data" command and remove them from here.
You may find the following documentation useful:

	https://docs.floydhub.com/guides/create_and_upload_dataset/
	https://docs.floydhub.com/guides/data/mounting_data/
	https://docs.floydhub.com/guides/floyd_ignore/
Code size too large to sync, please keep it under 100.0MiB.
If you have data files in the current directory, please upload them separately using "floyd data" command and remove them from here.
You may find the following documentation useful:

	https://docs.floydhub.com/guides/create_and_upload_dataset/
	https://docs.floydhub.com/guides/data/mounting_data/
	https://docs.floydhub.com/guides/floyd_ignore/
